# 학원 4주차 일일 오답노트 겸 개인정리

## 2022-12-19

### 1. 구조화를 하지 않은 프로그래밍의 단점

1. 선언한 변수간의 충돌도 잦아지고 엉키면서 변수 선언에서도 어려움을 겪는다.
2. 작성한 데이터들의 용도가 모호해진다.

### 2. 구조화 프로그래밍의 문제점

1. 변수의 데이터 구조를 한번 정의하고 나면 고치기 힘듬.
- 예를 들어 정의된 변수명을 고치게 되면 오류가 여러 곳에서 발생함.
2. 함수를 나누는 기준이 명확하지 않다. => 고립도 하락으로 이어진다.

### 3. 객체지향 프로그래밍
(실세계에서와 같은) 설계 -> 구현

1. 캡슐화

- 그저 함수들을 모아놓은 것이 캡슐화가 아니다. (단순한 클래스 생성이 캡슐화를 의미하지 않음.)
- 데이터 구조와 함수를 하나의 영역에 모아두는 것 => 이것은 곧 행위(Method)를 의미한다.
- 객체지향에서의 캡슐화의 핵심은 **"행위"** 이다.

2. 캡슐화를 통한 개체와 객체 생성

- 개체는 Class를 통해 구현한다.
- Class는 개체의 멤버변수와 Method로 이루어진다.
- Method와 일반 함수의 다른 점
> 일반 함수는 위치가 자유롭고, 단순히 구조화를 목적으로 보통 생성하기 때문에 구별이 쉽지 않다.
> Method의 경우 해당 개체의 "행위"를 목적으로 생성한다.
> 계속 나오는 "행위"는 "이 개체가 무언가를 행동한다" 라는 것이 중요하기에 반복강조한다.

3. 객체의 이모저모

- 객체지향에서는 객체의 속성보다는 행위가 중요하다.
- 객체에는 각각의 해쉬코드가 존재하여 가비지컬렉션에 의해 사용 후 정리된다.
- 실체나 객체, 인스턴스 모두 같은 말이다.

4. 객체의 사용 

- Exam 변수명 = new Exam();
- 캡슐화를 통한 객체 생성 후에는 메소드를 사용하게 되는데
``` java
변수명.input();
```
- 위와 같이 input 이라는 메소드를 사용시 점 앞의 인스턴스를 넘겨 받는다.
- Class 내에서 this는 본인 클래스의 참조변수이다. (쉽게 이해해보자면 본인 개체를 의미한다는 뜻.)
- Method 구현 중에 this를 사용하지 않고 지역변수와 멤버변수가 오버로딩 된다면 우선순위는 지역변수가 먼저이다. 따라서 꼭 멤버변수 값을 사용해야 한다면 this를 써줘야 한다.

5. static
- 함수가 인스턴스의 메소드가 아니라는 의미가 static이다.
- static으로 선언된 함수는 포지셔닝이 자유롭다.
- 따라서 static 함수 내에서는 this도 사용이 불가하다.

6. 생성자




