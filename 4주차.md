# 학원 4주차 일일 오답노트 겸 개인정리

## 2022-12-19

### 1. 구조화를 하지 않은 프로그래밍의 단점

1. 선언한 변수간의 충돌도 잦아지고 엉키면서 변수 선언에서도 어려움을 겪는다.
2. 작성한 데이터들의 용도가 모호해진다.

### 2. 구조화 프로그래밍의 문제점

1. 변수의 데이터 구조를 한번 정의하고 나면 고치기 힘듬.
- 예를 들어 정의된 변수명을 고치게 되면 오류가 여러 곳에서 발생함.
2. 함수를 나누는 기준이 명확하지 않다. => 고립도 하락으로 이어진다.

### 3. 객체지향 프로그래밍
(실세계에서와 같은) 설계 -> 구현

1. 캡슐화

- 그저 함수들을 모아놓은 것이 캡슐화가 아니다. (단순한 클래스 생성이 캡슐화를 의미하지 않음.)
- 데이터 구조와 함수를 하나의 영역에 모아두는 것 => 이것은 곧 행위(Method)를 의미한다.
- 객체지향에서의 캡슐화의 핵심은 **"행위"** 이다.

2. 캡슐화를 통한 개체와 객체 생성

- 개체는 Class를 통해 구현한다.
- Class는 개체의 멤버변수와 Method로 이루어진다.
- Method와 일반 함수의 다른 점
> 일반 함수는 위치가 자유롭고, 단순히 구조화를 목적으로 보통 생성하기 때문에 구별이 쉽지 않다.<br>
> Method의 경우 해당 개체의 "행위"를 목적으로 생성한다.<br>
> 계속 나오는 "행위"는 "이 개체가 무언가를 행동한다" 라는 것이 중요하기에 반복강조한다.

3. 객체의 이모저모

- 객체지향에서는 객체의 속성보다는 행위가 중요하다.
- 객체에는 각각의 해쉬코드가 존재하여 가비지컬렉션에 의해 사용 후 정리된다.
- 실체나 객체, 인스턴스 모두 같은 말이다.

4. 객체의 사용 

- Exam 변수명 = new Exam();
- 캡슐화를 통한 객체 생성 후에는 메소드를 사용하게 되는데
``` java
변수명.input();
```
- 위와 같이 input 이라는 메소드를 사용시 점 앞의 인스턴스를 넘겨 받는다.
- Class 내에서 this는 본인 클래스의 참조변수이다. (쉽게 이해해보자면 본인 개체를 의미한다는 뜻.)
- Method 구현 중에 this를 사용하지 않고 지역변수와 멤버변수가 오버로딩 된다면 우선순위는 지역변수가 먼저이다. 따라서 꼭 멤버변수 값을 사용해야 한다면 this를 써줘야 한다.

5. static
- 함수가 인스턴스의 메소드가 아니라는 의미가 static이다.
- static으로 선언된 함수는 포지셔닝이 자유롭다.
- 따라서 static 함수 내에서는 this도 사용이 불가하다.

6. 생성자
- 객체의 변수를 초기화 시키는 역할.
- 해당 클래스의 이름을 메소드명으로 선언하면 된다.
- Exam 변수명 = new Exam(); 처럼 객체를 생성할 때 마지막 (); 부분이 자바에서 생성자를 자동으로 호출해주는 곳이였다.
- 이것을 내가 원하는 초기화 값으로 설정해고 싶다면 객체클래스에서 선언해주면 된다.
- 생성자의 매개변수를 다르게 지정하여 정의할 수 있다. -> 생성자 오버로딩
- 일종의 메소드라 할 수 있지만 메소드와는 다르다. (썸인가..?)
- 이유 1 : 반드시 클래스명과 동일하게 정의해야 하고
- 이유 2 : 생성자 앞에는 접근제어자만 올 수 있다. (static 노노해)
- 이유 3 : 반환값이 없기때문에 void나 자료형을 작성하지 않는다.
- 한번 짚고 기억에 남겨두는 정도로 알아보자. (많이 쓰게 될거니까)

## 2022-12-20

### 1. 객체지향의 3요소 - 캡슐화, 상속, 다형성

### 2. 캡슐화에 대한 좀 더 정확한 이해

1. 캡슐화의 보편적인 정의 : 데이터 구조와 메소드들을 모아두는 것.
- 하지만 데이터 구조가 없다면? 아니면 데이터 구조만 존재한다면?
- 뉴렉쌤의 정의 : 역할(행위)를 가지고 있는 구성요소

2. '캡슐이 깨진다'의 의미 : 해당 캡슐의 변수나 메소드가 다른 캡슐에 영향을 주거나, 다른 캡슐에 의해 영향을 받게 되는 일.

3. 깨지지 않게 하기 위해선 접근 제어 지시자를 통해 제어해야 한다.
- private : 해당 객체(캡슐)내에서만 접근 가능
- public : 공공연하게~
- protected, default도 있지만 오늘은 여기까지만.

### 3. 오버로드

1. 메소드끼리 같은 이름을 가지게 되면 오버로드라고 한다. (과적)

2. 받는 인자의 차이에 따라 옵션을 가지게 되는데 순정을 기본함수, 옵션을 가진 함수는 오버로드 함수라 지칭한다.

3. 오버로드를 생성하게 되면 두 개 이상의 메소드가 같은 부분을 가지고 있게 되는데 기본 함수에 오버로드 함수를 사용하는 식으로 반복되지 않게 정리해주는 것이 좋다.

4. 생성자도 똑같이 오버로드를 이용할 수 있다.

5. 생성자 오버로드에서 기본 생성자에서 초기화해줄 때 본인 개체를 가르키기 위해서 this를 사용하게 되는데
그 전에는 사용되어서는 안된다.

### 4. 캡슐화를 유지하는 코드 재사용법, 객체 합성 (이 단어도 직역일 가능성이 있을듯.)

1. 캡슐을 데이터구조와 메소드 캡슐로 각각 나누면서도 깨지지 않게 하는 방법.

2. Dependency라는 단어의 뜻 의존, 종속을 그대로 번역하다보니 이해에 어려움이 있다.

3. 데어터구조의 캡슐을 부품이라고 생각하고 이해하도록 하자.

4. 은닉화된 부품에 접근하기 위해서는 게터세터 메소드가 필요하다.

5. 합성엔 두 가지 방법이 있다.
> 1) Composition Has a : 중간 콘솔 메소드 캡슐에서 구성이 완료되어있는 것, 또는 부품이 조립되어 있는 것.
> 2) Association Has a : 부품을 끼어넣어야 되는 것.

## 2022-12-21 (이날 배운건 더 정확한 정리와 이해가 필요)

### 1. Has a 결합
1) 기본적으로 Has a 관계는 클래스의 위아래가 있는 관계이다. 한 클래스가 상대 클래스의 부품 (종속)인 간계.
2) Association, Composition, Aggregation 의 차이는 무엇일까.
- Association : 뒤의 Compositon, Aggregation은 Association의 특별한 케이스 2가지인 경우.
즉 가장 합집합.
- Composition : 컴포지션의 특징은 나머지 클래스 부품들이 존재해야 그걸 가진 클래스가 온전해지는 경우.
- Aggregation : 무조건적인 부품이 아니라 클래스들 서로가 서로의 부품이 되는 경우.


### 2. DI (Dependency Injection)
1. 어떻게 관계를 생성하느냐 (조립하느냐)

2. Setter Injection
- set메소드를 생성해서 조립하는 방법
- A,B 클래스가 있다고 했을때 A.set(B); 같은 형식

3. Construction Injection
- 생성자를 통해서 조립하는 방법
- A = new A(B); 같은 형식


### 3. Is a 결합
1. 흔히 말하는 상속.

2. extands 를 사용해서 부모 자식 클래스 관계가 형성된다.

3. 부모의 틀을 가져와서 자식 클래스에서 사용하는 것이라고 이해하자.

4. 부모 클래스의 private 접근 제한을 갖는 필드 및 메소드는 자식이 물려받을 수 없다.

5. set을 통해 접근할 수 있지만, 은닉성이 사라지는 문제가 생김 => super 사용.

6. super 키워드 : 자식 클래스에서 부모 클래스를 가리킬 때 사용하는 키워드.

7. 부모의 메소드를 자식의 메소드에서 가져다 재생성 하는 것 : 오버라이드.

8. 오버로드 와는 다른 개념.


### 4. 상속 시 참조형식과 호출되는 메소드의 관게
1. newlacExam 클래스가 Exam 클래스에 상속되어 있을 때.

2. Exam exam = new NewlacExam(); 형식으로 생성 가능함.

3. 자식이 부모 메소드를 오버라이딩 했을 경우에 자식 메소드가 먼저 호출된다.

4. 부모 메소드를 사용할 때에도 자식 오버라이딩된 메소드를 먼저 호출한다.
